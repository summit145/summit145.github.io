<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Sledders 3D Pixel â€“ Ultimate Realistic</title>
<style>
html, body { margin:0; padding:0; background:#0b1622; overflow:hidden; }
canvas { display:block; margin:auto; image-rendering:pixelated; }
</style>
</head>
<body>
<canvas id="game" width="480" height="270"></canvas>
<script>
/* ================= CONFIG ================= */
const SCALE = 3;
const canvas = document.getElementById("game");
canvas.style.width = canvas.width * SCALE + "px";
canvas.style.height = canvas.height * SCALE + "px";
const ctx = canvas.getContext("2d");

const WORLD_SIZE = 3000;
const GRID = 16;
const CHUNK_RENDER_RADIUS = 25;
let timeOfDay = 0;
let headlightOn = true;
const keys = {};
onkeydown = e => keys[e.key.toLowerCase()] = true;
onkeyup = e => keys[e.key.toLowerCase()] = false;

/* ================= TERRAIN ================= */
const terrain = [];
const numPeaks = 5;
const peaks = [];
for(let i=0;i<numPeaks;i++){
    peaks.push({
        x: Math.random()*WORLD_SIZE,
        y: Math.random()*WORLD_SIZE,
        height: 150 + Math.random()*100
    });
}
for(let x=0;x<WORLD_SIZE/GRID;x++){
    terrain[x]=[];
    for(let y=0;y<WORLD_SIZE/GRID;y++){
        let h=0;
        peaks.forEach(p=>{
            const dx = x*GRID - p.x;
            const dy = y*GRID - p.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            h += Math.max(0, p.height - dist*0.15);
        });
        h += Math.random()*15;
        terrain[x][y] = h;
    }
}

/* ================= TREES ================= */
const trees=[];
for(let i=0;i<150;i++){
    trees.push({
        x:Math.random()*WORLD_SIZE,
        y:Math.random()*WORLD_SIZE,
        h:6+Math.random()*6,
        color:`rgb(${30+Math.random()*50},${80+Math.random()*60},${20+Math.random()*40})`,
        snowCap: Math.random()<0.6
    });
}

/* ================= FREERIDE TRAILS ================= */
const trails = [];
for(let i=0;i<numPeaks;i++){
    let trailX = peaks[i].x - 200 + Math.random()*400;
    let trailY = peaks[i].y - 200 + Math.random()*400;
    for(let j=0;j<50;j++){
        trails.push({x: trailX, y: trailY, life:200});
        trailX += 20 + Math.random()*20;
        trailY += 20 + Math.random()*20;
    }
}

/* ================= PLAYER ================= */
const player = {
    x: WORLD_SIZE/2,
    y: WORLD_SIZE/2,
    z:0,
    angle:0,
    speed:0,
    lean:0,
    tilt:0,
    width:8,
    height:12,
    airborne:false,
    rotation:0,
    crashCooldown:0
};

/* ================= SNOW & PARTICLES ================= */
const snowflakes=[];
for(let i=0;i<300;i++){
    snowflakes.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        dy: 0.2 + Math.random()*0.3,
        dx: (Math.random()*0.2-0.1),
        size: 1 + Math.random()*1
    });
}
const powder = [];
const sparks = [];

/* ================= AUDIO ================= */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const engineOsc = audioCtx.createOscillator();
const engineGain = audioCtx.createGain();
engineOsc.type = "sawtooth";
engineOsc.frequency.setValueAtTime(100, audioCtx.currentTime);
engineGain.gain.setValueAtTime(0, audioCtx.currentTime);
engineOsc.connect(engineGain).connect(audioCtx.destination);
engineOsc.start();

/* ================= HELPERS ================= */
function getTerrainHeight(x,y){
    const gx=Math.floor(x/GRID);
    const gy=Math.floor(y/GRID);
    if(terrain[gx] && terrain[gx][gy]!==undefined) return terrain[gx][gy];
    return 0;
}
function getSlope(x,y){
    const gx=Math.floor(x/GRID);
    const gy=Math.floor(y/GRID);
    if(terrain[gx] && terrain[gx][gy]!==undefined){
        const h = terrain[gx][gy];
        const hx = terrain[gx+1]?terrain[gx+1][gy]:h;
        const hy = terrain[gx][gy+1]!==undefined?terrain[gx][gy+1]:h;
        return {dx:hx-h, dy:hy-h};
    }
    return {dx:0, dy:0};
}

/* ================= UPDATE ================= */
function update(){
    timeOfDay += 0.0003;

    // Controls
    if(keys["w"] || keys["arrowup"]) player.speed += 0.15;
    if(keys["s"] || keys["arrowdown"]) player.speed *= 0.9;
    if(keys["a"] || keys["arrowleft"]) player.angle -= 0.05;
    if(keys["d"] || keys["arrowright"]) player.angle += 0.05;
    if(keys["h"]) headlightOn = !headlightOn;

    // Respawn
    if(keys["r"]){
        player.x = WORLD_SIZE/2;
        player.y = WORLD_SIZE/2;
        player.speed = 0;
        player.angle = 0;
        player.z = getTerrainHeight(player.x,player.y);
        player.tilt = 0;
        player.rotation = 0;
        player.airborne=false;
        player.crashCooldown=0;
    }

    const terrainZ = getTerrainHeight(player.x,player.y);

    // Air check
    player.airborne = player.z > terrainZ+1;

    // Crash cooldown
    if(player.crashCooldown>0) player.crashCooldown--;

    // Physics
    const slope = getSlope(player.x,player.y);
    const slopeEffect = -(slope.dx*Math.cos(player.angle) + slope.dy*Math.sin(player.angle))*0.12;
    player.speed += slopeEffect;
    player.speed *= 0.985;

    // Movement
    player.x += Math.cos(player.angle)*player.speed;
    player.y += Math.sin(player.angle)*player.speed;

    // Collide with trees
    trees.forEach(t=>{
        const dx = player.x - t.x;
        const dy = player.y - t.y;
        if(Math.sqrt(dx*dx+dy*dy)<6 && player.crashCooldown<=0){
            player.speed = 0;
            player.crashCooldown = 50;
            for(let i=0;i<5;i++){
                sparks.push({
                    x:player.x + (Math.random()-0.5)*10,
                    y:player.y + (Math.random()-0.5)*10,
                    life:20
                });
            }
        }
    });

    // Terrain collision & air physics
    if(!player.airborne){
        player.z = terrainZ;
        player.tilt = 0;
        player.rotation = 0;
    } else {
        // Air tilt physics
        if(keys["w"] || keys["arrowup"]) player.tilt += 0.02;
        else player.tilt -= 0.02;
        if(keys["a"] || keys["arrowleft"]) player.rotation -= 0.03;
        if(keys["d"] || keys["arrowright"]) player.rotation += 0.03;

        player.tilt = Math.max(Math.min(player.tilt,0.5),-0.5);
        player.rotation = Math.max(Math.min(player.rotation,Math.PI/2),-Math.PI/2);

        // Gravity
        player.z -= 0.5; 
        if(player.z<terrainZ){
            // Landing effect
            const impact = player.tilt;
            if(Math.abs(impact)>0.3){
                player.speed *= 0.5;
                sparks.push({x:player.x, y:player.y, life:30});
            }
            player.z = terrainZ;
            player.airborne=false;
            player.tilt=0;
            player.rotation=0;
        }
    }

    // Powder
    if(Math.abs(player.speed)>1){
        const count = Math.floor(player.speed*2);
        for(let i=0;i<count;i++){
            const angleOffset = (Math.random()-0.5)*Math.PI/3 + Math.PI;
            const dist = Math.random()*4 + 2;
            powder.push({
                x: player.x + Math.cos(player.angle+angleOffset)*dist,
                y: player.y + Math.sin(player.angle+angleOffset)*dist,
                dx: Math.cos(angleOffset)*0.2,
                dy: Math.sin(angleOffset)*0.2,
                life: 20 + Math.random()*10
            });
        }
    }
    powder.forEach(p=>{p.x+=p.dx; p.y+=p.dy; p.life--;});
    for(let i=powder.length-1;i>=0;i--){if(powder[i].life<=0) powder.splice(i,1);}
    sparks.forEach(s=>s.life--);
    for(let i=sparks.length-1;i>=0;i--){if(sparks[i].life<=0) sparks.splice(i,1);}

    // Snowflakes
    snowflakes.forEach(f=>{
        f.x+=f.dx; f.y+=f.dy;
        if(f.y>canvas.height) f.y=0;
        if(f.x<0) f.x=canvas.width;
        if(f.x>canvas.width) f.x=0;
    });

    // Trails
    if(player.speed>1 && !player.airborne){
        trails.push({x:player.x, y:player.y, life:200});
    }
    for(let i=trails.length-1;i>=0;i--){trails[i].life--; if(trails[i].life<=0) trails.splice(i,1);}

    // Engine sound
    const throttle = Math.max(0, player.speed / 5);
    engineGain.gain.linearRampToValueAtTime(throttle * 0.5, audioCtx.currentTime + 0.05);
    engineOsc.frequency.linearRampToValueAtTime(100 + throttle*200, audioCtx.currentTime + 0.05);

    // Bounds
    player.x = Math.max(0,Math.min(WORLD_SIZE,player.x));
    player.y = Math.max(0,Math.min(WORLD_SIZE,player.y));
}

/* ================= DRAW ================= */
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const night = (Math.sin(timeOfDay)+1)/2;

    // Sky
    const skyColor = night>0.5?"#a0d8ff":"#0a1b2c";
    ctx.fillStyle=skyColor;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Camera offset
    const viewOffsetX = canvas.width/2 - player.x;
    const viewOffsetY = canvas.height/2 - player.y - player.z*0.5;

    // Terrain
    const startX = Math.floor(player.x/GRID)-CHUNK_RENDER_RADIUS;
    const endX = Math.floor(player.x/GRID)+CHUNK_RENDER_RADIUS;
    const startY = Math.floor(player.y/GRID)-CHUNK_RENDER_RADIUS;
    const endY = Math.floor(player.y/GRID)+CHUNK_RENDER_RADIUS;

    for(let gx=startX; gx<=endX; gx++){
        for(let gy=startY; gy<=endY; gy++){
            if(terrain[gx]!==undefined && terrain[gx][gy]!==undefined){
                const h = terrain[gx][gy];
                const px = gx*GRID + viewOffsetX;
                const py = gy*GRID + viewOffsetY - h*0.5;
                const shade = 180 - h;
                ctx.fillStyle=`rgb(${shade},${shade},255)`;
                ctx.fillRect(px,py,GRID,GRID);
            }
        }
    }

    // Trails
    ctx.fillStyle="rgba(200,200,255,0.3)";
    trails.forEach(t=>{
        const px = t.x + viewOffsetX;
        const py = t.y + viewOffsetY - getTerrainHeight(t.x,t.y)*0.5;
        ctx.fillRect(px,py,GRID/2,GRID/2);
    });

    // Trees
    trees.forEach(t=>{
        const px = t.x + viewOffsetX;
        const py = t.y + viewOffsetY - getTerrainHeight(t.x,t.y)*0.5;
        if(px<0||px>canvas.width||py<0||py>canvas.height) return;
        ctx.fillStyle="#5a3b1a";
        ctx.fillRect(px,py,2,t.h);
        ctx.fillStyle=t.color;
        ctx.beginPath();
        ctx.moveTo(px-2,py);
        ctx.lineTo(px+6,py);
        ctx.lineTo(px+2,py-4);
        ctx.closePath();
        ctx.fill();
        if(t.snowCap){
            ctx.fillStyle="rgba(255,255,255,0.7)";
            ctx.fillRect(px,py-4,4,2);
        }
    });

    // Powder
    ctx.fillStyle="rgba(255,255,255,0.9)";
    powder.forEach(p=>{
        const px = p.x + viewOffsetX;
        const py = p.y + viewOffsetY - getTerrainHeight(p.x,p.y)*0.5;
        ctx.fillRect(px,py,1,1);
    });

    // Sparks
    ctx.fillStyle="orange";
    sparks.forEach(s=>{
        const px = s.x + viewOffsetX;
        const py = s.y + viewOffsetY - getTerrainHeight(s.x,s.y)*0.5;
        ctx.fillRect(px,py,2,2);
    });

    // Snowmobile
    const cx = canvas.width/2;
    const cy = canvas.height/2 - player.z*0.5;
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(player.angle + player.rotation);

    // Tilt
    ctx.rotate(player.tilt);

    // Skis
    ctx.fillStyle="#222222";
    ctx.fillRect(-5,-5,2,12);
    ctx.fillRect(3,-5,2,12);

    // Body
    ctx.fillStyle="#c40000";
    ctx.beginPath();
    ctx.moveTo(-6,-5);
    ctx.lineTo(6,-5);
    ctx.lineTo(4,5);
    ctx.lineTo(-4,5);
    ctx.closePath();
    ctx.fill();

    // Driver
    ctx.fillStyle="#555555";
    ctx.fillRect(-2,-10,4,5);

    // Headlight
    if(headlightOn){
        ctx.fillStyle="rgba(255,255,200,0.15)";
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(50,-25);
        ctx.lineTo(50,25);
        ctx.closePath();
        ctx.fill();
    }

    ctx.restore();

    // Snowflakes
    ctx.fillStyle="rgba(255,255,255,0.9)";
    snowflakes.forEach(f=>ctx.fillRect(f.x,f.y,f.size,f.size));

    // Mini-map
    ctx.fillStyle="#000000aa";
    ctx.fillRect(canvas.width-62,2,60,60);
    for(let gx=0;gx<terrain.length;gx+=4){
        for(let gy=0;gy<terrain[0].length;gy+=4){
            const h = terrain[gx][gy];
            const px = canvas.width-62 + gx/terrain.length*60;
            const py = 2 + gy/terrain[0].length*60;
            const shade = 150 - h;
            ctx.fillStyle=`rgb(${shade},${shade},${shade})`;
            ctx.fillRect(px,py,1,1);
        }
    }
    trees.forEach(t=>{
        const px = canvas.width-62 + t.x/WORLD_SIZE*60;
        const py = 2 + t.y/WORLD_SIZE*60;
        ctx.fillStyle="#fff";
        ctx.fillRect(px,py,1,1);
    });
    ctx.fillStyle="#ff0000";
    ctx.fillRect(canvas.width-62 + player.x/WORLD_SIZE*60, 2 + player.y/WORLD_SIZE*60,2,2);

    // Compass
    ctx.save();
    ctx.translate(canvas.width-32,70);
    ctx.rotate(player.angle);
    ctx.fillStyle="#fff";
    ctx.beginPath();
    ctx.moveTo(0,-6);
    ctx.lineTo(2,2);
    ctx.lineTo(-2,2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Night overlay
    if(night<0.4){
        ctx.fillStyle="rgba(0,20,40,0.25)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
    }
}

/* ================= LOOP ================= */
function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
