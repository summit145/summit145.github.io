<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Top-Down Open World Shooter</title>
<style>
body { margin:0; overflow:hidden; background:#111; }
canvas { display:block; margin:auto; background:#222; }
#ui { position:absolute; top:10px; left:10px; color:white; font-family:Arial; z-index:10; }
#healthBar { width:200px; height:20px; background:red; border:2px solid white; }
#ammoCount, #scoreDisplay, #levelDisplay { margin-top:5px; }
</style>
</head>
<body>
<div id="ui">
  <div id="healthBar"></div>
  <div id="ammoCount">Ammo: 30</div>
  <div id="scoreDisplay">Score: 0</div>
  <div id="levelDisplay">Level: 1</div>
</div>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// -------------------- INPUT --------------------
const keys = {};
let mouse = {x:0, y:0, pressed:false};
window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);
window.addEventListener('mousemove', e=>{mouse.x=e.clientX; mouse.y=e.clientY;});
window.addEventListener('mousedown', e=>mouse.pressed=true);
window.addEventListener('mouseup', e=>mouse.pressed=false);

// -------------------- GAME STATE --------------------
let score = 0, level = 1;
let bullets=[], grenades=[], enemies=[], pickups=[], obstacles=[];
let lastEnemySpawn = Date.now(), lastPickupSpawn = Date.now();
const worldWidth = 4000, worldHeight = 4000;

// -------------------- UTILS --------------------
function dist(x1,y1,x2,y2){return Math.hypot(x1-x2,y1-y2);}
function removeFromArray(obj,arr){const i=arr.indexOf(obj); if(i>-1) arr.splice(i,1);}
function updateUI(){
  document.getElementById('healthBar').style.width=(player.health*2)+'px';
  document.getElementById('ammoCount').innerText='Ammo: '+player.weapon.ammo+' | Grenades: '+player.grenades;
  document.getElementById('scoreDisplay').innerText='Score: '+score;
  document.getElementById('levelDisplay').innerText='Level: '+level;
}

// -------------------- OBSTACLES --------------------
class Obstacle{
  constructor(x,y,w,h){
    this.x=x; this.y=y; this.w=w; this.h=h;
  }
  draw(camX,camY){
    ctx.fillStyle='darkgreen';
    ctx.fillRect(this.x-camX,this.y-camY,this.w,this.h);
  }
  collides(x,y,size){
    return x+size/2>this.x && x-size/2<this.x+this.w &&
           y+size/2>this.y && y-size/2<this.y+this.h;
  }
}
function generateObstacles(){
  for(let i=0;i<100;i++){
    const w=50+Math.random()*50, h=50+Math.random()*50;
    const x=Math.random()*(worldWidth-w);
    const y=Math.random()*(worldHeight-h);
    obstacles.push(new Obstacle(x,y,w,h));
  }
}
generateObstacles();

// -------------------- PLAYER --------------------
class Player{
  constructor(){
    this.x=worldWidth/2; this.y=worldHeight/2;
    this.size=40; this.speed=4;
    this.health=100; this.maxHealth=100;
    this.weapons=[
      {name:'Pistol',ammo:15,maxAmmo:15,fireRate:300,damage:20,level:1},
      {name:'SMG',ammo:30,maxAmmo:30,fireRate:100,damage:10,level:1},
      {name:'Shotgun',ammo:5,maxAmmo:5,fireRate:800,damage:15,bulletsPerShot:5,spread:0.3,level:1}
    ];
    this.currentWeapon=0;
    this.lastShot=0;
    this.grenades=3;
    this.exp=0;
  }
  get weapon(){return this.weapons[this.currentWeapon];}
  switchWeapon(){this.currentWeapon=(this.currentWeapon+1)%this.weapons.length; updateUI();}
  shoot(){
    const now = Date.now();
    if(now-this.lastShot<this.weapon.fireRate || this.weapon.ammo<=0) return;
    this.lastShot=now;
    if(this.weapon.name==='Shotgun'){
      for(let i=0;i<this.weapon.bulletsPerShot;i++){
        const angle=Math.atan2(mouse.y - canvas.height/2, mouse.x - canvas.width/2) + Math.random()*this.weapon.spread - this.weapon.spread/2;
        bullets.push(new Bullet(this.x,this.y,angle,this.weapon.damage*this.weapon.level));
      }
    } else {
      const angle=Math.atan2(mouse.y - canvas.height/2, mouse.x - canvas.width/2);
      bullets.push(new Bullet(this.x,this.y,angle,this.weapon.damage*this.weapon.level));
    }
    this.weapon.ammo--;
    updateUI();
  }
  throwGrenade(){
    if(this.grenades>0){
      grenades.push(new Grenade(this.x,this.y,mouse.x + this.x - canvas.width/2, mouse.y + this.y - canvas.height/2));
      this.grenades--;
      updateUI();
    }
  }
  update(){
    let dx=0,dy=0;
    if(keys['w']) dy-=1; if(keys['s']) dy+=1;
    if(keys['a']) dx-=1; if(keys['d']) dx+=1;
    const len=Math.hypot(dx,dy); if(len>0){dx/=len; dy/=len;}
    let newX=this.x+dx*this.speed; let newY=this.y+dy*this.speed;
    // collision with obstacles
    obstacles.forEach(ob=>{if(ob.collides(newX,newY,this.size)){newX=this.x; newY=this.y;}});
    this.x=newX; this.y=newY;
    if(mouse.pressed)this.shoot();
  }
  gainExp(amount){
    this.exp+=amount;
    if(this.exp>=100){this.levelUp(); this.exp=0;}
  }
  levelUp(){level++; this.weapon.level++; updateUI();}
  draw(camX,camY){
    ctx.save(); ctx.translate(this.x - camX, this.y - camY);
    const angle=Math.atan2(mouse.y - canvas.height/2, mouse.x - canvas.width/2);
    ctx.rotate(angle); ctx.fillStyle='blue';
    ctx.fillRect(-this.size/2,-this.size/2,this.size,this.size);
    ctx.restore();
    ctx.fillStyle='red';
    ctx.fillRect(canvas.width/2-25,20,50*(this.health/this.maxHealth),5);
    ctx.strokeStyle='white'; ctx.strokeRect(canvas.width/2-25,20,50,5);
  }
}

// -------------------- BULLETS --------------------
class Bullet{
  constructor(x,y,angle,damage){
    this.x=x; this.y=y; this.speed=12; this.size=8;
    this.dx=Math.cos(angle)*this.speed; this.dy=Math.sin(angle)*this.speed;
    this.damage=damage;
  }
  update(){
    this.x+=this.dx; this.y+=this.dy;
    // collision with obstacles
    obstacles.forEach(ob=>{
      if(ob.collides(this.x,this.y,this.size)) removeFromArray(this,bullets);
    });
    enemies.forEach(e=>{
      if(dist(this.x,this.y,e.x,e.y)<this.size/2+e.size/2){e.health-=this.damage; removeFromArray(this,bullets); score+=10; player.gainExp(5);}
    });
  }
  draw(camX,camY){
    ctx.fillStyle='yellow'; ctx.beginPath(); ctx.arc(this.x-camX,this.y-camY,this.size/2,0,Math.PI*2); ctx.fill();
  }
}

// -------------------- GRENADES --------------------
class Grenade{
  constructor(x,y,targetX,targetY){
    this.x=x; this.y=y; this.size=15; this.speed=8; this.timer=2000;
    const angle=Math.atan2(targetY-y,targetX-x);
    this.dx=Math.cos(angle)*this.speed; this.dy=Math.sin(angle)*this.speed;
    this.spawnTime=Date.now(); this.blastRadius=80; this.damage=50;
  }
  update(){
    this.x+=this.dx; this.y+=this.dy;
    if(Date.now()-this.spawnTime>=this.timer){
      enemies.forEach(e=>{if(dist(this.x,this.y,e.x,e.y)<this.blastRadius){e.health-=this.damage; score+=20; player.gainExp(10);}});
      removeFromArray(this,grenades);
    }
  }
  draw(camX,camY){ctx.fillStyle='orange'; ctx.beginPath(); ctx.arc(this.x-camX,this.y-camY,this.size/2,0,Math.PI*2); ctx.fill();}
}

// -------------------- ENEMIES --------------------
class Enemy{
  constructor(x,y,type='normal'){
    this.x=x; this.y=y; this.size=35; this.health=50;
    this.type=type;
    if(type==='fast'){this.speed=3; this.health=30;}
    else if(type==='tank'){this.speed=1.5; this.health=100;}
    else this.speed=2;
  }
  update(){
    const dx=player.x-this.x; const dy=player.y-this.y; const len=Math.hypot(dx,dy);
    if(len>0){this.x+=dx/len*this.speed; this.y+=dy/len*this.speed;}
    if(len<this.size/2 + player.size/2) player.health-=0.5;
  }
  draw(camX,camY){ctx.fillStyle=this.type==='tank'?'darkred':this.type==='fast'?'orange':'red'; ctx.beginPath(); ctx.arc(this.x-camX,this.y-camY,this.size/2,0,Math.PI*2); ctx.fill();}
}

// -------------------- PICKUPS --------------------
class Pickup{
  constructor(x,y,type){
    this.x=x; this.y=y; this.size=20; this.type=type;
    this.value=type==='health'?30:15;
  }
  update(){
    if(dist(player.x,player.y,this.x,this.y)<player.size/2+this.size/2){
      if(this.type==='health') player.health=Math.min(player.maxHealth,player.health+this.value);
      else if(this.type==='ammo') player.weapon.ammo=Math.min(player.weapon.maxAmmo,player.weapon.ammo+this.value);
      removeFromArray(this,pickups); updateUI();
    }
  }
  draw(camX,camY){ctx.fillStyle=this.type==='health'?'green':'orange'; ctx.beginPath(); ctx.arc(this.x-camX,this.y-camY,this.size/2,0,Math.PI*2); ctx.fill();}
}

// -------------------- GAME LOOP --------------------
const player = new Player();
function spawnEnemyType(){
  const types=['normal','fast','tank'];
  const type = types[Math.floor(Math.random()*types.length)];
  enemies.push(new Enemy(Math.random()*worldWidth,Math.random()*worldHeight,type));
}

function gameLoop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const camX = player.x - canvas.width/2;
  const camY = player.y - canvas.height/2;

  const now = Date.now();
  if(now-lastEnemySpawn>2000){spawnEnemyType(); lastEnemySpawn=now;}
  if(now-lastPickupSpawn>7000){pickups.push(new Pickup(Math.random()*worldWidth,Math.random()*worldHeight,Math.random()<0.5?'health':'ammo')); lastPickupSpawn=now;}

  // Draw world
  ctx.fillStyle='#444'; ctx.fillRect(-camX,-camY,worldWidth,worldHeight);
  obstacles.forEach(o=>o.draw(camX,camY));

  player.update(); player.draw(camX,camY);
  bullets.forEach(b=>{b.update(); b.draw(camX,camY);});
  grenades.forEach(g=>{g.update(); g.draw(camX,camY);});
  enemies.forEach((e,i)=>{e.update(); if(e.health<=0){score+=20; player.gainExp(10); removeFromArray(e,enemies);} else e.draw(camX,camY);});
  pickups.forEach(p=>{p.update(); p.draw(camX,camY);});

  if(player.health<=0){
    ctx.fillStyle='white'; ctx.font='50px Arial'; ctx.fillText('GAME OVER',canvas.width/2-150,canvas.height/2); return;
  }

  requestAnimationFrame(gameLoop);
}
updateUI();
gameLoop();

// -------------------- KEYBINDINGS --------------------
window.addEventListener('keydown', e=>{
  if(e.key.toLowerCase()==='r') player.weapon.ammo = player.weapon.maxAmmo;
  if(e.key.toLowerCase()==='q') player.switchWeapon();
  if(e.key.toLowerCase()==='g') player.throwGrenade();
});
</script>
</body>
</html>
